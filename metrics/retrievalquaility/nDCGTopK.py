import math
from typing import Iterable, Dict, Set

"""
Computes nDCG on the Top-k retrieved documents. Class was initialially generated by ChatGPT and edited by github copilot
and then modified by the author to fit the codebase style to text in MA thesis also some comments were added.

Parameters
----------
retrieved_ids : iterable of str
    Ranked list of retrieved document IDs.
relevant_ids : iterable of str
    Collection of relevant document IDs.

Returns
-------
float
    nDCG value in [0, 1].
"""

class nDCGTopK:
    def __init__(self, k: int):
        if k <= 0:
            raise ValueError("k must be a positive integer")
        self.k = k
    
    @staticmethod
    def _dcg(relevances: Iterable[int]) -> float:
        """
        Computes Discounted Cumulative Gain.
        """
        dcg = 0.0
        for i, rel in enumerate(relevances, start=1):
            dcg += (2 ** rel - 1) / math.log2(i + 1)
        return dcg

    def compute(
        self,
        retrieved_ids: Iterable[str],
        relevant_ids: Iterable[str],
    ) -> float:

        relevant_set: Set[str] = set(relevant_ids)

        top_k = list(retrieved_ids)[: self.k]

        # Step 1: Binary relevance vector for retrieved ranking (Gained vector)
        # 1 if relevant, 0 otherwise
        # renamed rel_vector to relevant_vector for clarity
        relevant_vector = [1 if doc_id in relevant_set else 0 for doc_id in top_k]

        # Step 2: Compute DCG for the retrieved ranking
        dcg = self._dcg(relevant_vector)

        # Step 3: Ideal ranking - all relevant docs first
        # renamed ideal_rels to ideal_relevances for clarity
        # renamed iDCG to ideal_dcg for clarity
        ideal_relevances = sorted(relevant_vector, reverse=True)
        ideal_dcg = self._dcg(ideal_relevances)

        # Handle edge case where ideal DCG is 0
        if ideal_dcg == 0.0:
            return 0.0

        # Step 4: Compute nDCG as ratio of DCG to ideal DCG (normalization)
        return dcg / ideal_dcg
